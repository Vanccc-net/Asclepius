# Asclepius.Auth - Сервис аутентификации и управления профилями (Микросервисная архитектура)

##  Обзор проекта

**Asclepius.Auth** — это высоконадежный, распределенный сервис аутентификации, разработанный в парадигме **Микросервисов**. Он отвечает за регистрацию, аутентификацию пользователей, генерацию JWT-токенов и асинхронную рассылку уведомлений и создания профиля.

Проект построен с использованием **Чистой Архитектуры (Clean Architecture / Onion Architecture)** и принципов **Domain-Driven Design (DDD)**, что обеспечивает высокую масштабируемость и поддерживаемость.

##  Архитектура и основные технологии

### Основные принципы:

* **Чистая Архитектура / DDD:** Строгое разделение на слои Домена, Бизнес-логики, Представления и Инфраструктуры. Использование **Объектов-Значений (Value Objects)**, **Фабричных методов** и **Репозиториев**.
* **Паттерн Mediator:** Использование **MediatR** для отделения HTTP-контроллеров от основной бизнес-логики (`AuthController` лишь отправляет команды).
* **Транзакционная надежность:** Применение **Unit of Work** для обеспечения атомарности транзакций и **Transactional Outbox Pattern (через MassTransit)** для гарантии доставки асинхронных сообщений.

### Технологический стек:

| Стек | Технология | Назначение |
| :--- | :--- | :--- |
| **Backend** | .NET 8 (C#) | Основной фреймворк |
| **База данных** | PostgreSQL, Entity Framework Core | Хранение пользователей и ролей |
| **Кэширование** | Redis | Хранение рефреш-токенов / данных сессий |
| **Обмен сообщениями**| MassTransit (RabbitMQ / Kafka) | Асинхронная коммуникация между микросервисами |
| **CI/CD** | Docker / Docker Compose | Контейнеризация и оркестрация |
| **Мониторинг** | Prometheus, Grafana, Serilog | Сбор метрик, визуализация и структурированное логирование |

## Highload возможности
Проект оптимизирован под высокие нагрузки. Я проводил нагрузочное тестирование с помощью k6

| Параметр | Значение                       |
| :--- |:-------------------------------|
| **Virtual Users** | 5,000 concurrent users         |
| **Длительность** | 2 минуты 50 секунд             |
| **Цель теста** | Регистрация нового пользователя |
| **Всего запросов** | 1,332,672                      |
| **RPS** | 7,839                          |
| **Ошибок** | 0%                             |
| **Время обработки для 95%** | 642ms |

### Сценарий теста:
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '30s', target: 200 }, // Ramp-up: 30 сек до 200 VUs
    { duration: '30s', target: 350 }, // Ramp-up: 30 сек до 350 VUs
    { duration: '30s', target: 500 }, // Stress: 30 сек до 500 VUs
    { duration: '10s', target: 2000 }, // Stress: 10 сек до 2000 VUs
    { duration: '1m', target: 5000 }, // Stress: 1 м до 5000 VUs
    { duration: '10s', target: 0 },

  ],
  thresholds: {
    // 95% запросов должны завершаться быстрее 1000мс
    http_req_duration: ['p(95) < 1000'],
    // Менее 1% запросов могут завершиться ошибкой
    http_req_failed: ['rate < 0.01'],
  },
};

export default function () {
  const url = 'http://localhost:8080/api/auth/Register/false';
  
  const payload = JSON.stringify({
    email: `testuser_${__VU}_${__ITER}_${Math.random()}@example.com`, 
    password: 'stringstringstringstring',
    firstName: 'Test',
    lastName: 'User',
    dateOfBirth: '2025-10-04',
    gender: 0
  });

  const params = {
    headers: {
      'accept': '*/*',
      'Content-Type': 'application/json',
    },
  };

  const response = http.post(url, payload, params);

  // Проверяем статус ответа
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 1000ms': (r) => r.timings.duration < 1000,
  });
}
```


##  Как запустить проект

Проект полностью контейнеризован и запускается одной командой с помощью Docker Compose.

**Предварительные условия:**

1.  Установлен Docker и Docker Compose.

**Запуск:**

1.  Перейдите в корневую директорию проекта, где находится файл `docker-compose.yml`.
2.  Выполните команду:
    ```bash
    docker-compose up --build -d
    ```

Процесс займет несколько минут, поскольку будет собрано 3+ сервисов.

### Конечные точки:

| Сервис | Порт | Адрес | Описание |
| :--- | :--- | :--- | :--- |
| **Auth API (Swagger)** | `http://localhost:8080` | `/` | Главный API, документация и тесты |
| **Grafana** | `http://localhost:3000` | | Панель мониторинга метрик |
| **RabbitMQ** | `http://localhost:15672` | `guest/guest` | UI для управления очередями |

##  Точки внимания (для оценки)

Я бы хотел обратить особое внимание на следующие архитектурные решения:

1.  **UserController:** Максимально "тонкий" контроллер. Он не содержит бизнес-логики, а лишь отправляет команды через `IMediator`.
2.  **Password Value Object:** Логика хеширования пароля (BCrypt) инкапсулирована в `Domain/UserObject/Password.cs`, обеспечивая гарантию валидности и безопасности.
3.  **ApplicationContext:** Использование **Value Converters** для сохранения `Value Objects` и подключение **Transactional Outbox** для надежности сообщений.
4.  **Unit Tests (в работе):** Для Command Handlers используются **xUnit** и **Moq** для тестирования бизнес-логики в изоляции от инфраструктуры.